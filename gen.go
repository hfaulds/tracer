package main

import (
	"fmt"
	"sort"
	"strings"
)

func Generate(pkg *Package) string {
	// If there are no interfaces with methods which have context.Context as an
	// argument then there is nothing to generate.
	if shouldSkipPackage(pkg) {
		return ""
	}

	var b strings.Builder
	/*
		// Code generated by tracer v0.0.1. DO NOT EDIT.
	*/

	fmt.Fprint(&b, "// Code generated by tracer v0.0.1. DO NOT EDIT.\n\n")

	/*
		package main
	*/
	fmt.Fprintf(&b, "package %s\n\n", pkg.Name)

	/*
		import (
			i0 "context"
			i1 "some/dependency"
		)
	*/
	importMap := buildImportMap(pkg)
	generateImports(&b, importMap)

	/*
		type spanType = interface{ Finish() }
	*/
	fmt.Fprint(&b, "\ntype spanType = interface {\n\tFinish()\n\tWithError(error) error\n}\n")

	childSpanType := fmt.Sprintf("func(%s.Context, string) (%s.Context, spanType)", importMap["context"], importMap["context"])

	for _, iface := range pkg.Interfaces {
		// Skip interfaces where no methods have context.Context as an argument
		if shouldSkipInterface(iface) {
			continue
		}
		fmt.Fprint(&b, "\n")

		/*
			type traceExample struct {
				wrapped Example
			}
		*/
		structName := fmt.Sprintf("trace%s", iface.Name)
		fmt.Fprintf(&b, "type %s struct {\n", structName)
		fmt.Fprintf(&b, "\twrapped   %s\n", iface.Name)
		fmt.Fprintf(&b, "\tchildSpan %s\n", childSpanType)
		fmt.Fprintf(&b, "}")

		/* func NewExampleTracer(p0 Example) Example {
			return traceExample {
				wrapped p0,
			}
		}*/
		fmt.Fprint(&b, "\n\nfunc ")
		generateMethodSig(&b, "", fmt.Sprintf("New%sTracer", strings.Title(iface.Name)), []string{iface.Name, childSpanType}, []string{iface.Name})
		fmt.Fprint(&b, " {\n")
		fmt.Fprintf(&b, "\treturn %s{\n", structName)
		fmt.Fprintf(&b, "\t\twrapped:   p0,\n")
		fmt.Fprintf(&b, "\t\tchildSpan: p1,\n")
		fmt.Fprintf(&b, "\t}\n")
		fmt.Fprintf(&b, "}")

		/*
			func (t traceExample) Foo(p0 context.Context, p1) i1.example {
				ctx, span := t.childSpan(p0)
				defer span.Finish()
				return t.wrapped.Foo(p0,p1)
			}
		*/
		for _, m := range iface.Methods {
			params := resolveParams(importMap, m.Params)
			returns := resolveParams(importMap, m.Returns)
			fmt.Fprint(&b, "\n\nfunc ")
			generateMethodSig(&b, structName, m.Name, params, returns)
			fmt.Fprint(&b, " {\n")
			// only add tracing if there a context
			offset, ok := getFirstContextParamOffset(m)
			if ok {
				fmt.Fprintf(&b, "\tctx, span := t.childSpan(p%d, \"%s\")\n", offset, m.Name)
				fmt.Fprint(&b, "\tdefer span.Finish()\n")
			}
			generateWrappedCall(&b, m, len(params), offset)
			fmt.Fprintf(&b, "}")
		}
		fmt.Fprint(&b, "\n")
	}
	return b.String()
}

func generateMethodSig(b *strings.Builder, implementor, methodName string, params, returns []string) {
	if implementor != "" {
		fmt.Fprintf(b, "(t %s) ", implementor)
	}
	fmt.Fprintf(b, "%s(", methodName)
	for i, param := range params {
		fmt.Fprintf(b, "p%d %s", i, param)
		if i < len(params)-1 {
			fmt.Fprint(b, ", ")
		}
	}
	fmt.Fprint(b, ")")
	if len(returns) > 0 {
		fmt.Fprint(b, " ")
	}
	if len(returns) > 1 {
		fmt.Fprint(b, "(")
	}
	for i, r := range returns {
		if i > 0 {
			fmt.Fprint(b, ", ")
		}
		fmt.Fprint(b, r)
	}
	if len(returns) > 1 {
		fmt.Fprint(b, ")")
	}
}

func buildImportMap(pkg *Package) map[string]string {
	importMap := map[string]string{}
	for _, i := range pkg.Interfaces {
		for _, p := range resolveMethodPackages(i.Methods) {
			if p == pkg.PkgPath {
				continue
			}
			if _, ok := importMap[p]; !ok {
				importMap[p] = fmt.Sprintf("i%d", len(importMap))
			}
		}
	}
	return importMap
}

func resolveMethodPackages(methods []method) []string {
	var pkgs []string
	for _, m := range methods {
		for _, p := range m.Params {
			pkgs = append(pkgs, resolvePackages(p)...)
		}
		for _, p := range m.Returns {
			pkgs = append(pkgs, resolvePackages(p)...)
		}
	}
	return pkgs
}

func resolvePackages(p param) []string {
	switch tp := p.(type) {
	case namedParam:
		if tp.pkg == "" {
			return []string{}
		}
		return []string{tp.pkg}
	case arrayParam:
		return resolvePackages(tp.typ)
	case sliceParam:
		return resolvePackages(tp.typ)
	case pointerParam:
		return resolvePackages(tp.typ)
	case mapParam:
		return append(resolvePackages(tp.key), resolvePackages(tp.elem)...)
	case interfaceParam:
		return resolveMethodPackages(tp.methods)
	default:
		return []string{}
	}
}

func generateImports(b *strings.Builder, importMap map[string]string) {
	var imports []string
	for imp, alias := range importMap {
		imports = append(imports, fmt.Sprintf("import %s \"%s\"", alias, imp))
	}
	sort.Strings(imports)
	fmt.Fprintf(b, strings.Join(imports, "\n"))
	if len(imports) > 0 {
		fmt.Fprintf(b, "\n")
	}
}

func shouldSkipPackage(p *Package) bool {
	for _, i := range p.Interfaces {
		if !shouldSkipInterface(i) {
			return false
		}
	}
	return true
}

func shouldSkipInterface(i Interface) bool {
	for _, m := range i.Methods {
		if _, ok := getFirstContextParamOffset(m); ok {
			return false
		}
	}
	return true
}

var contextNamedParam = namedParam{pkg: "context", typ: "Context"}

func getFirstContextParamOffset(m method) (int, bool) {
	for i, p := range m.Params {
		if np, ok := p.(namedParam); ok {
			if np == contextNamedParam {
				return i, true
			}
		}
	}
	return -1, false
}

func resolveParams(importMap map[string]string, params []param) []string {
	resolved := make([]string, 0, len(params))
	for _, p := range params {
		resolved = append(resolved, resolveParam(importMap, p))
	}
	return resolved
}

func resolveParam(importMap map[string]string, p param) string {
	switch tp := p.(type) {
	case basicParam:
		return tp.typ
	case namedParam:
		if tp.pkg != "" {
			if alias, ok := importMap[tp.pkg]; ok {
				return fmt.Sprintf("%s.%s", alias, tp.typ)
			} else {
				return tp.typ
			}
		}
		return tp.typ
	case arrayParam:
		return fmt.Sprintf("[%d]%s", tp.length, resolveParam(importMap, tp.typ))
	case sliceParam:
		return fmt.Sprintf("[]%s", resolveParam(importMap, tp.typ))
	case pointerParam:
		return fmt.Sprintf("*%s", resolveParam(importMap, tp.typ))
	case mapParam:
		return fmt.Sprintf("map[%s]%s", resolveParam(importMap, tp.key), resolveParam(importMap, tp.elem))
	case interfaceParam:
		var b strings.Builder
		if len(tp.methods) == 0 {
			fmt.Fprint(&b, "interface{}")
		} else if len(tp.methods) == 1 {
			fmt.Fprint(&b, "interface{ ")
			m := tp.methods[0]
			params := resolveParams(importMap, m.Params)
			returns := resolveParams(importMap, m.Returns)
			generateMethodSig(&b, "", m.Name, params, returns)
			fmt.Fprint(&b, " }")
		} else {
			fmt.Fprint(&b, "interface {")
			for _, m := range tp.methods {
				fmt.Fprint(&b, "\n\t")
				params := resolveParams(importMap, m.Params)
				returns := resolveParams(importMap, m.Returns)
				generateMethodSig(&b, "", m.Name, params, returns)
			}
			fmt.Fprint(&b, "\n},\n")
		}
		return b.String()
	default:
		return "<unsupported>"
	}
}

func generateWrappedCall(b *strings.Builder, m method, numParams, contextOffset int) {
	fmt.Fprint(b, "\t")
	numReturns := len(m.Returns)
	errorOffset, returnsError := getLastErrorReturnOffset(m)
	if numReturns > 0 {
		if returnsError {
			for i := 0; i < numReturns; i++ {
				fmt.Fprintf(b, "r%d", i)
				if i != numReturns-1 {
					fmt.Fprint(b, ", ")
				}
			}
			fmt.Fprint(b, " := ")
		} else {
			fmt.Fprint(b, "return ")
		}
	}
	fmt.Fprintf(b, "t.wrapped.%s(", m.Name)
	for i := 0; i < numParams; i++ {
		if i == contextOffset {
			fmt.Fprint(b, "ctx")
		} else {
			fmt.Fprintf(b, "p%d", i)
		}
		if i != numParams-1 {
			fmt.Fprint(b, ", ")
		}
	}
	fmt.Fprint(b, ")\n")
	if returnsError {
		fmt.Fprint(b, "\treturn ")
		for i := 0; i < numReturns; i++ {
			if i == errorOffset {
				fmt.Fprintf(b, "span.WithError(r%d)", i)
			} else {
				fmt.Fprintf(b, "r%d", i)
			}
			if i != numReturns-1 {
				fmt.Fprint(b, ", ")
			}
		}
		fmt.Fprint(b, "\n")
	}
}

var errorNamedParam = namedParam{pkg: "", typ: "error"}

func getLastErrorReturnOffset(m method) (int, bool) {
	for i := len(m.Returns) - 1; i >= 0; i-- {
		p := m.Returns[i]
		if np, ok := p.(namedParam); ok {
			if np == errorNamedParam {
				return i, true
			}
		}
	}
	return -1, false
}
