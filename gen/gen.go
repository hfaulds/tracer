package gen

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"sort"
	"strings"

	"github.com/hfaulds/tracer/parse/types"
)

type Builder interface {
	WriteTo(io.Writer) (int, error)

	WriteStruct(types.Struct)
	WriteMethod(*types.Struct, types.Method, func(b Builder))
	WriteLine(string, ...interface{})
	Write(string, ...interface{})
}

type builder struct {
	buf       *bytes.Buffer
	importMap map[string]string
}

func NewBuilder(pkg *types.Package) Builder {
	importMap := buildImportMap(pkg)

	var buf bytes.Buffer
	fmt.Fprint(&buf, "// Code generated by tracer v0.0.1. DO NOT EDIT.\n\n")
	fmt.Fprintf(&buf, "package %s\n\n", pkg.Name)
	writeImports(&buf, importMap)
	return builder{
		buf:       &buf,
		importMap: importMap,
	}
}

func (b builder) WriteTo(w io.Writer) (int, error) {
	formatted, err := format.Source(b.buf.Bytes())
	if err != nil {
		return 0, err
	}
	return w.Write([]byte(formatted))
}

func (b builder) WriteStruct(strct types.Struct) {
	fmt.Fprintf(b.buf, "\ntype %s struct {\n", strct.Name)
	for attrName, attrType := range strct.Attrs {
		fmt.Fprintf(b.buf, "%s %s\n", attrName, resolveParam(b.importMap, attrType))
	}
	fmt.Fprintf(b.buf, "}\n")
}

func (b builder) WriteMethod(strct *types.Struct, method types.Method, callback func(b Builder)) {
	fmt.Fprint(b.buf, "\nfunc ")
	if strct != nil {
		fmt.Fprintf(b.buf, "(t %s) ", strct.Name)
	}
	generateMethodSig(b.buf, "", method.Name, resolveParams(b.importMap, method.Params), resolveParams(b.importMap, method.Returns))
	fmt.Fprint(b.buf, " {\n")
	callback(b)
	fmt.Fprintf(b.buf, "\n}\n")
}

func (b builder) WriteLine(str string, a ...interface{}) {
	b.Write(str+"\n", a...)
}

func (b builder) Write(str string, a ...interface{}) {
	fmt.Fprintf(b.buf, str, a...)
}

func resolveParams(importMap map[string]string, params []types.Param) []string {
	resolved := make([]string, 0, len(params))
	for _, p := range params {
		resolved = append(resolved, resolveParam(importMap, p))
	}
	return resolved
}

func resolveParam(importMap map[string]string, p types.Param) string {
	switch tp := p.(type) {
	case types.BasicParam:
		return tp.Typ
	case types.NamedParam:
		if tp.Pkg != "" {
			if alias, ok := importMap[tp.Pkg]; ok {
				return fmt.Sprintf("%s.%s", alias, tp.Typ)
			} else {
				return tp.Typ
			}
		}
		return tp.Typ
	case types.ArrayParam:
		return fmt.Sprintf("[%d]%s", tp.Length, resolveParam(importMap, tp.Typ))
	case types.SliceParam:
		return fmt.Sprintf("[]%s", resolveParam(importMap, tp.Typ))
	case types.PointerParam:
		return fmt.Sprintf("*%s", resolveParam(importMap, tp.Typ))
	case types.MapParam:
		return fmt.Sprintf("map[%s]%s", resolveParam(importMap, tp.Key), resolveParam(importMap, tp.Elem))
	case types.InterfaceParam:
		var b strings.Builder
		if len(tp.Methods) == 0 {
			fmt.Fprint(&b, "interface{}")
		} else if len(tp.Methods) == 1 {
			fmt.Fprint(&b, "interface{ ")
			m := tp.Methods[0]
			params := resolveParams(importMap, m.Params)
			returns := resolveParams(importMap, m.Returns)
			generateMethodSig(&b, "", m.Name, params, returns)
			fmt.Fprint(&b, " }")
		} else {
			fmt.Fprint(&b, "interface {")
			for _, m := range tp.Methods {
				fmt.Fprint(&b, "\n")
				params := resolveParams(importMap, m.Params)
				returns := resolveParams(importMap, m.Returns)
				generateMethodSig(&b, "", m.Name, params, returns)
			}
			fmt.Fprint(&b, "\n},\n")
		}
		return b.String()
	default:
		return "<unsupported>"
	}
}

func generateMethodSig(b io.Writer, implementor, methodName string, params, returns []string) {
	if implementor != "" {
		fmt.Fprintf(b, "(t %s) ", implementor)
	}
	fmt.Fprintf(b, "%s(", methodName)
	for i, param := range params {
		fmt.Fprintf(b, "p%d %s", i, param)
		if i < len(params)-1 {
			fmt.Fprint(b, ", ")
		}
	}
	fmt.Fprint(b, ")")
	if len(returns) > 0 {
		fmt.Fprint(b, " ")
	}
	if len(returns) > 1 {
		fmt.Fprint(b, "(")
	}
	for i, r := range returns {
		if i > 0 {
			fmt.Fprint(b, ", ")
		}
		fmt.Fprint(b, r)
	}
	if len(returns) > 1 {
		fmt.Fprint(b, ")")
	}
}

func writeImports(b io.Writer, importMap map[string]string) {
	var imports []string
	for imp, alias := range importMap {
		imports = append(imports, fmt.Sprintf("import %s \"%s\"", alias, imp))
	}
	sort.Strings(imports)
	fmt.Fprintf(b, strings.Join(imports, "\n"))
	if len(imports) > 0 {
		fmt.Fprintf(b, "\n")
	}
}
