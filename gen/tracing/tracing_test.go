package tracing_test

import (
	"bytes"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/hfaulds/tracer/gen"
	"github.com/hfaulds/tracer/gen/tracing"
	"github.com/hfaulds/tracer/parse/types"
)

const (
	tracePkg = "tracing"
)

func TestTracing(t *testing.T) {
	tests := []struct {
		desc  string
		iface types.Interface
		exp   string
	}{
		{
			desc:  "empty interface",
			iface: types.Interface{Name: "test"},
			exp: `// Code generated by tracer v0.0.1. DO NOT EDIT.
package test

import trace "tracing"

type traceTest struct {
	wrapped test
}

func NewTestTracer(p0 test) test {
	return traceTest{
		wrapped: p0,
	}
}
`,
		},
		{
			desc: "method with context",
			iface: types.Interface{
				Name: "test",
				Methods: []types.Method{
					{
						Name: "WithContext",
						Params: []types.Param{
							types.NamedParam{Pkg: "context", Typ: "Context"},
						},
					},
				},
			},
			exp: `// Code generated by tracer v0.0.1. DO NOT EDIT.
package test

import i0 "context"
import trace "tracing"

type traceTest struct {
	wrapped test
}

func NewTestTracer(p0 test) test {
	return traceTest{
		wrapped: p0,
	}
}

func (t traceTest) WithContext(p0 i0.Context) {
	ctx, span := trace.ChildSpan(p0, trace.OpName("WithContext"))
	defer span.Finish()
	t.wrapped.WithContext(ctx)
}
`,
		},
		{
			desc: "method returning error",
			iface: types.Interface{
				Name: "test",
				Methods: []types.Method{
					{
						Name: "ReturnsError",
						Params: []types.Param{
							types.NamedParam{Pkg: "context", Typ: "Context"},
						},
						Returns: []types.Param{
							types.NamedParam{Typ: "error"},
						},
					},
				},
			},
			exp: `// Code generated by tracer v0.0.1. DO NOT EDIT.
package test

import i0 "context"
import trace "tracing"

type traceTest struct {
	wrapped test
}

func NewTestTracer(p0 test) test {
	return traceTest{
		wrapped: p0,
	}
}

func (t traceTest) ReturnsError(p0 i0.Context) error {
	ctx, span := trace.ChildSpan(p0, trace.OpName("ReturnsError"))
	defer span.Finish()
	r0 := t.wrapped.ReturnsError(ctx)
	return span.WithError(r0)
}
`,
		},
		{
			desc: "multiple contexts, multiple errors",
			iface: types.Interface{
				Name: "test",
				Methods: []types.Method{
					{
						Name: "MultipleContextsMultipleErrors",
						Params: []types.Param{
							types.NamedParam{Pkg: "context", Typ: "Context"},
							types.NamedParam{Pkg: "context", Typ: "Context"},
						},
						Returns: []types.Param{
							types.NamedParam{Typ: "error"},
							types.NamedParam{Typ: "error"},
						},
					},
				},
			},
			exp: `// Code generated by tracer v0.0.1. DO NOT EDIT.
package test

import i0 "context"
import trace "tracing"

type traceTest struct {
	wrapped test
}

func NewTestTracer(p0 test) test {
	return traceTest{
		wrapped: p0,
	}
}

func (t traceTest) MultipleContextsMultipleErrors(p0 i0.Context, p1 i0.Context) (error, error) {
	ctx, span := trace.ChildSpan(p0, trace.OpName("MultipleContextsMultipleErrors"))
	defer span.Finish()
	r0, r1 := t.wrapped.MultipleContextsMultipleErrors(ctx, p1)
	return r0, span.WithError(r1)
}
`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.desc, func(t *testing.T) {
			pkg := &types.Package{Name: "test"}
			pkg.Interfaces = append(pkg.Interfaces, tt.iface)
			b := gen.NewBuilder(pkg)
			tracing.Gen(b, tt.iface, tracePkg)
			var buf bytes.Buffer
			_, err := b.WriteTo(&buf)
			require.NoError(t, err)
			assert.Equal(t, tt.exp, buf.String())
		})
	}
}
